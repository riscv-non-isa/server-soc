== Server SoC Test Specification

=== Clocks and Timers

[width=100%]
[%header, cols="8,25"]
|===
| ID#            ^| Algorithm
| ME_CTI_010_010 a| On each RISC-V application-processor hart, set the hart’s
                    operating frequency to the lowest supported fixed frequency
                    *F*. If the implementation does not support operation at a
                    fixed frequency, this test is skipped.                     +
                                                                               +
                    Record the initial values of the `time` and `cycles` CSRs
                    as `T1` and `C1` respectively. Poll the `time` CSR until it
                    has advanced by 1 × 10^9^ ticks, and then record the final
                    value of the `time` and `cycles` CSR as `T2` and `C2`
                    respectively.                                              +
                                                                               +
                    Verify that:
                    ((C2 − C1)/(T2 - T1)) x 10^9^ = F ± E-CTI_020_010          +
                                                                               +
                    where *E-CTI_020_010* is a test-suite-defined tolerance.
| ME_CTI_020_010 a| Determine the low-power states implemented by each RISC-V
                    application-processor hart using the system information
                    table.                                                     +
                                                                               +
                    On each application-processor hart, for each supported low-
                    power state, verify that the timer context is preserved
                    across the low-power state by programming the `stimecmp` to
                    cause a timer interrupt in the future, entering the low-
                    power state, and upon wakeup verifying that `time` matches
                    the expected wakeup time.
|===

<<<

=== External Interrupt Controllers

[width=100%]
[%header, cols="8,25"]
|===
| ID#            ^| Algorithm
| ME_IIC_010_010 a| See ME_IIC_030_010.
| ME_IIC_020_010 a| See ME_IIC_030_010.
| MF_IIC_030_010 a| For each application processor hart:
                    . Verify presence of `siselect` and `sireg` CSRs provided
                      by the Sscsrind extension. Verify that bit 60 of
                      `hstateen0` CSR is writable.
                    . Verify presence of `stopi` CSR provided by Ssaia
                      extension. Verify that bit 59 of `hstateen0` CSR is
                      writable.
                    . Verify presence of `stopei` CSR provided by Ssaia
                      extension. Verify that bit 58 of `hstateen0` CSR is
                      writable.
                    . For each external interrupt identity supported by the
                      S-level interrupt file, verify the ability to set the
                      corresponding bit in the `eip__k__` and `eie__k__`
                      registers. Verify that at least 255 interrupt identities
                      are supported.
                    . Verify ability to enable and disable interrupt delivery in
                      the `eidelivery` register.
                    . Map the physical address of the S-mode interrupt register
                      file of the hart with a virtual address using PBMT set to
                      IO. The physical address is determined using the system
                      information table.
                    . Write a supported external interrupt identity to the
                      S-level interrupt register file using a 4-byte store to
                      the `seteipnum_le` register using virtual address
                      established in previous step.
                    . Read the `seteipnum_le` register using a 4-byte load to
                      verify it reads 0.
                    . Verify that the written external interrupt identity is
                      recorded in the `eip__k__` register of the IMSIC.
                    . Determine the highest priority pending and enabled
                      interrupt in the `eip__k__` registers.
                    . Read the `stopei` register to verify that the highest
                      priority external interrupt identity is reported.
                    . Clear any external interrupts pended or enabled in the
                      IMSIC by this test by clearing the corresponding bits in
                      the `eip__k__` and `eie__k__` registers.
| ME_IIC_040_010 a| Use WARL discovery method on `hstatus.VGEIN` CSR field to
                    determine the `GEILEN` and verify that at least 5 guest
                    interrupt files are supported.
| ME_IIC_050_010 a| See ME_IIC_030_010.
| ME_IIC_060_010 a| For each application processor hart:
                    . Verify presence of `vsiselect`, `vsireg`, `vstopi`, and
                      `vstopei` CSRs.
                    . For each guest interrupt file, determine the number of
                      guest mode interrupt identities supported by verifying the
                      ability to set the corresponding bit in `eip__k__` and
                      `eie__k`__` registers of the guest interrupt file. Verify
                      that at least 63 interrupt identities are supported.
| ME_IIC_070_010 a| See MF_IIC_030_010.
| ME_IIC_080_010 a| . Parse the system information table to determine if an APLIC
                      for supervisor interrupt domain is reported.
                    . If no APLIC is reported then skip the remaining steps.
                    . Locate the APLIC related information in the system
                      information table.
                    . Verify that number of interrupt delivery controls
                      is reported as 0 indicating it is used as a wired-to-MSI
                      bridge.
                    . Verify that `domaincfg` supports MSI delivery mode and can
                      be configured to be in MSI delivery mode.
                    . Write an external interrupt ID to `genmsi` register and
                      verify that the extempore MSI is delivered to the IMSIC
                      of the targeted hart.
                    . Verify that the guest index field of the `target[i]`
                      registers support all values between 0 and `GEILEN` supported
                      by the IMSIC.
|===

<<<

=== Input-Output Memory Management Unit (IOMMU)

[width=100%]
[%header, cols="8,25"]
|===
| ID#            ^| Algorithm
| ME_IOM_010_010 a| . Locate all IOMMUs using the system information table.
                    . For each IOMMU, read the `capabilities` register and
                      verify that it supports version 1.0 of the RISC-V IOMMU
                      specification.
                    . Output the `capabilities` register in the test output log.
| ME_IOM_020_010 a| . Use PCIe discovery to locate all RCiEPs and PCIe RPs.
                    . Locate the system information table entries of all IOMMUs
                    . For each RCiEP, verify that there is a governing IOMMU.
                    . For each RP, verify that there is a governing IOMMU.
| ME_IOM_030_010 a| . Locate all IOMMUs governing PCIe root ports.
                    . For each located IOMMU:
                      .. if `capabilities.MSI_FLAT` is 0, then the `ddtp` must
                         support at least 2 level DDT.
                      .. if `capabilities.MSI_FLAT` is 1, then the `ddtp` must
                         support 3 level DDT.
| ME_IOM_040_010 a| For each IOMMU that does not govern a PCIe root port:
                    . From the system information table entry of that IOMMU,
                      determine the widest device ID.
                    . Verify that the `ddtp` supports a mode that supports the
                      widest device ID.
| ME_IOM_050_010 a| . Using WARL discovery determine the page based virtual
                      memory systems supported by the application processor
                      harts.
                    . For each IOMMU in reported:
                      .. Verify that the `capabilities` register enumerates
                         support for each of the page based virtual memory
                         system modes supported by the harts.
| OE_IOM_060_010 a| See ME_IOM_010_010.
| OE_IOM_070_010 a| See ME_IOM_010_010.
| ME_IOM_080_010 a| For each IOMMU, verify that if `capabilities.MSI_MRIF` is
                    equal to `capabilities.AMO_MRIF`.
| OE_IOM_090_010 a| See ME_IOM_010_010.
| OE_IOM_100_010 a| See ME_IOM_010_010.
| ME_IOM_110_010 a| . Use PCIe discovery to locate all RCiEPs.
                    . For each RCiEP:
                      .. If PCIe ATS capability not supported by the RCiEP
                         then continue.
                      .. Locate the governing IOMMU using system information
                         table.
                      .. Verify that the `capabilities.ATS` is 1 in the
                         governing IOMMU.
| OE_IOM_120_010 a| See ME_IOM_010_010.
| ME_IOM_130_010 a| For each IOMMU, verify that if `capabilities.IGS` is either
                    0 or 2.
| ME_IOM_140_010 a| For each IOMMU, verify that if `fctl.BE` is either read-only
                    zero or is writeable. Verify that the support is identical
                    for all IOMMUs. If big-endian mode supported then emit the
                    support status in the test output log.
| OE_IOM_150_010 a| See ME_IOM_140_010.
| OE_IOM_160_010 a| See ME_IOM_010_010.
| ME_IOM_170_010 a| For each IOMMU, verify that if any of the `PD8`, `PD17`, or
                    `PD20` bits are 1 in the `capabilities` register then `PD20`
                    bit must be 1.
| OE_IOM_180_010 a| See ME_IOM_010_010.
| ME_IOM_190_010 a| For each IOMMU:

                    . if `capabilities.HPM` is 0 then continue.
                    . Verify `iohpmcycles` and its `OF` bit are writeable and
                      the cycles counter is at least 40-bit wide.
                    . Verify at least four programmable HPM counters are
                      supported and the counters for each are at least 40-bit
                      wide.
                    . Verify that the bits corresponding to the implemented
                      HPM counters in `iocountovf` and `iocountinh` are
                      writeable.
                    . Verify that the `iohpmcycles` is at least 40-bit wide.
                    . Verify that the `CY` bit in `iocountovf` and `iocountinh` is
                      writeable.
| ME_IOM_200_010 a| See ME_IOM_090_010.
| OE_IOM_210_010 a| See ME_IOM_010_010.
| ME_IOM_220_010 a| . Determine the width of the `PPN` field in `hgatp` and
                      multiply that by 4096 to determine the PA size supported
                      by the hart.
                    . Verify that the `capabilities.PAS` is greater than equal
                      to the PA size supported by the hart.
| ME_IOM_230_010 a| No test.
| OE_IOM_240_010 a| . Do a PCIe scan to locate all RCiEP of IOMMU class and report
                      the bus:device:function numbers of the IOMMUs in the test
                      output log.
| ME_IOM_250_010 a| No test.
| ME_IOM_260_010 a| . Parse the PCIe root complex device binding information from
                      the system information table and build a mapping of root
                      complexes associated with each IOMMU.
                    . For each IOMMU determine the PCIe segment number of the
                      associated PCIe root complexes and create a list of IOMMUs
                      that govern multiple root complexes where the PCIe root
                      complexes belong to two or more PCIe segments.
                    . For each IOMMU that governs PCIe root complexes that are
                      part of different PCIe segments verify that the `ddtp`
                      supports 3 level DDT.
| ME_IOM_270_010 a| No test.
| OE_IOM_280_010 a| No test.
| ME_IOM_290_010 a| No test.
|===

<<<

=== PCIe Subsystem Integration

==== Enhanced Configuration Access Method (ECAM)

[width=100%]
[%header, cols="8,25"]
|===
| ID#            ^| Algorithm
| MF_ECM_010_010 a| . Parse system information table to local all ECAM ranges.
                    . For each 4 KiB range in the ECAM range, verify that the
                      following reads do not cause any errors or exceptions.
                      .. 4-bytes at offset 0 - vendor and device ID
                      .. 2-bytes at offset 0 - vendor ID
                      .. 1 byte at offset 8 - revision ID
| MF_ECM_020_010 a| . Use PCIe discovery to locate the RISC-V PCIe test card.
                    . Capture timestamp A from `time` CSR.
                    . Write to `TEST_REG_1` in the test card DVSEC with a
                      timeout value of 100 ns to request that the completion
                      for CfgWr be generated after 1000 ns.
                    . Issue a `fence iorw, iorw` instruction.
                    . Capture timestamp B from `time` CSR.
                    . Verify that the two timestamps are at least 1000 ns apart.
| MF_ECM_030_010 a| . Parse system information table and obtain ECAM ranges for
                      all heirarchies.
                    . Verify that the ECAM ranges for each hierarchy are all
                      contigous and the base address is naturally aligned to
                      the size.
                    . Verify ranges of any two heirarchies do not overlap.
| MF_ECM_040_010 a| See MF_ECM_030_010.
| MF_ECM_050_010 a| TBA.
| MF_ECM_060_010 a| . This test requires an input parameter that indicates
                      which primary bus number and root port can be used for
                      this test. The test should be able to disable and enable
                      the link associated with that root port without causing
                      system instability (e.g., disabling link used to connect
                      to boot device, etc.). Let the primary bus number be P and
                      the RID of the root port be R.
                    . Verify D is located on bus P.
                    . Read vendor ID and device ID of all functions, including
                      R, on bus P and record the results.
                    . Disable the link using the link control register of R.
                    . Read vendor ID and device ID of all functions on P and
                      verify that they match values read before the link was
                      disabled.
                    . Enable the link using the link control register of R.
| ME_ECM_080_010 a| For each PCIe root port in the system:

                    . Read root capability register and verify that Configuration
                      RRS Software Visibility is supported.
| MF_ECM_090_010 a| . This test takes the PCIe root port to which the test card
                      is connected as an input parameter.
                    . Increment the subordinate bus number of the root port.
                    . Read the vendor ID of function on subordinate bus and
                      verify that the PCIe test card receives a type 1
                      transaction.
                    . Read the vendor ID of the test card on the secondary bus
                      and verify that the PCIe test card receives a type 0
                      transaction.
                    . Restore the subordinate bus number of the root port.
| MF_ECM_100_010 a| . This test requires an input parameters to use for the test:
                      .. A primary bus number P.
                      .. ECAM base address of the segment that includes P.
                      .. The RID of a root port R on the primary bus P.
                      .. The RID of a non-existent function NF on the bus P.
                      .. The RID of a device D downstream of P that can be reset
                         by the test.
                    . Read PCIe header of R and verify it is of type 1.
                    . Read vendor ID offset of NF and verify all 1's returned.
                    . Write command register offset of NF and verify no errors or
                      exceptions occur.
                    . Make an unaligned 2 and 4 byte read to configuration space
                      of R and verify all 1's returned.
                    . Read PCIe header of D and verify it is of type 0 and note
                      its vendor and device ID.
                    . Disable CRS software visibility in R.
                    . Issue FLR to D.
                    . Read vendor ID of D and verify all 1's returned.
                    . Keep reading vendor ID till D is discovered.
                    . Enable CRS software visibility in R.
                    . Issue FLR to D.
                    . Read vendor ID of D and verify 0x0001 returned.
                    . Read device ID of D and verify all 1s returned.
                    . Keep reading vendor ID till D is discovered.
                    . Disable link of R.
                    . Read vendor ID of D and verify all 1's returned.
                    . Enable link of R.
| MF_ECM_110_010 a| See MF_ECM_100_010.
| ME_ECM_120_010 a| No test.
|===

<<<

==== PCIe Memory Space

[width=100%]
[%header, cols="8,25"]
|===
| ID#            ^| Algorithm
| ME_MMS_010_010 a| Use system information table to locate PCI host bridges and
                    collect the memory ranges routed to each host bridge. Verify
                    that each host bridge has a memory range available for use
                    with 64-bit BARs and a memory range available for use with
                    32-bit BARs.
| ME_MMS_020_010 a| See ME_MMS_010_010.
| MF_MMS_030_010 a| . Use PCIe discovery to locate the RISC-V PCIe test card.
                    . Map the BAR 0 of the test card as IO memory using PBMT
                      attribute.
                    . Write data values to the `SCRATCHPAD` registers in BAR 0
                      using and read them back.
| MF_MMS_040_010 a| This test requires the following inputs:

                      .. A primary bus number P.
                      .. ECAM base address of the segment that includes P.
                      .. The RID of a root port R on the primary bus P.
                      .. Changing the memory or prefetchable memory base/limit
                         on R should not lead to any system instability i.e.
                         R is not connected to the main NVMe/Network, etc.

                    . Read the memory base/limit and prefetchable memory
                      base/limit of the ranges bridged downstream of R.
                    . Change limit to reduce the memory limit range by 1 MiB.
                      Let this excluded 1 MiB range be E.
                    . Perform 1, 2, 4, and 8 byte reads to locations in E and
                      verify that all 1s is returned.
                    . Perform 1, 2, 4, and 8 byte write to locations in E and
                      verify that all no errors or exceptions occur.
                    . Restore the memory limit and repeat same steps with the
                      prefetchable memory limit.
                    . Restore prefetchable memory limit to original value.
                    . Disable link of R
                    . Read 1, 2, 4, and 8 bytes from locations in memory
                      base/limit range and prefetchable memory base/limit range
                      and verify all 1s data returned.
                    . Enable link R.
| MF_MMS_050_010 a| See ME_MMS_040_010.
| MF_MMS_060_010 a| This test requires the use of two functions of the RISC-V
                    PCIe test cards. This test is optional if peer-to-peer DMA
                    is not supported by the system. One test card function -
                    card-f0 - is used as an initiator and the second card
                    function - card-f1 - is used as a responder.

                    . Disable poisoned TLP egress blocking in the root ports
                      connecting to the test card.
                    . Program the card-f0 to read from the `TEST_POISON_REG` in
                      BAR 0 of card-f1.
                    . Verify that card-f0 receives completion with EP=1.

| MF_MMS_070_010 a| . Use PCIe discovery to locate the RISC-V PCIe test card and
                      memory map its BAR 0 as IO memory.
                    . Read the MMIO register - `TEST_POISON_REG` in BAR 0 that
                      responds with poisoned data.
                    . Verify that either a hardware error exception occurs on
                      the load instruction or the load returns all 1s data.
| ME_MMS_080_010 a| . For each PCIe root port, verify that no EA capability is
                      reported.
|===

<<<

==== Access Control Services (ACS)

[width=100%]
[%header, cols="8,25"]
|===
| ID#            ^| Algorithm
| ME_ACS_010_010 a| For each PCIe root port:

                    . Verify ACS extended capability is supported.
                    . Verify that the ACS capability register reports support for
                      .. ACS source validation.
                      .. ACS translation blocking.
                      .. ACS I/O request blocking.
                    . Report ACS capability register into test output log.
| ME_ACS_020_010 a|  For each PCIe root port:
                     . If BAR0 or BAR1 are implemented, then verify that the ACS
                       capability register supports ACS Enhanced Capability.
| ME_ACS_030_010 a| No test.
| ME_ACS_040_010 a| No test.
| ME_ACS_050_010 a| No test.
|===

<<<

==== Address Routed Transactions

[width=100%]
[%header, cols="8,25"]
|===
| ID#            ^| Algorithm
| MF_ADR_010_010 a| . Use PCIe discovery to locate the RISC-V PCIe test card.
                    . Configure IOMMU govering the test card with an invalid
                      device context for the test card.
                    . Initiate Translated Mrd, Untranslated Mrd, and a PCIe ATS
                      translation request from the test card.
                    . Verify that the IOMMU reports a "DDT entry not valid"
                      fault for each of the transactions.
                    . Verify that the test card receives a Unsupported Request
                      (UR) response to each of the transactions.
| MF_ADR_020_010 a| . Use PCIe discovery to locate the RISC-V PCIe test card.
                    . Determine the address range of system memory reserved for
                      machine mode use. This may be a test input.
                    . Configure the IOMMU govering the test card to allow
                      read and write access to the reserved system memory range
                      and enable use of ATS by the test card.
                    . Initiate Translated Mrd and Untranslated Mrd request from
                      the test card with an address in the reserved memory
                      range.
                    . Verify that the test card receives a Unsupported Request
                      (UR) response to each of the transactions.
| MF_ADR_030_010 a| This test requires the use of two functions of the RISC-V
                    PCIe test card. One function - card-f0 - is used as an
                    initiator and the second function - card-f1 - is used as a
                    responder.

                    . Program the IOMMU govering the card-f0 to remap the
                      physical address range corresponding BAR 0 of card-f1 to
                      an equally sized system memory buffer in page tables set
                      up for card-f0.
                    . Program card-f0 to initiate a memory read to an address
                      in BAR 0 of card-f1 using an Untranslated request.
                    . Verify that the data returned to card-f0 is from the
                      corresponding offset in the system memory buffer and no
                      transaction is received by card-f1.
| MF_ADR_040_010 a| This test uses same setup as MF_ADR_030_010.

                    . Program the IOMMU govering the card-f0 to disallow access
                      to physical address range corresponding BAR 0 of card-f1
                      for DMA originating from card-f0. This test uses a Bare
                      G-stage.
                    . Program card-f0 to perform a memory read to the BAR 0 of
                      card-f1.
                    . Verify an Unsupported Request response is received and the
                      IOMMU reports a "Read page fault".
                    . Program card-f0 to perform a memory write to the BAR 0 of
                      card-f1.
                    . Verify that the IOMMU reports a "Write/AMO page fault".
| MF_ADR_050_010 a| This test uses same setup as MF_ADR_040_010.

                    . Program the IOMMU govering the card-f0 to allow read and
                      write access to physical address range corresponding
                      BAR 0 of card-f1 for DMA originating from card-f0.
                    . Disable poisoned TLP egress blocking in the root ports
                      connecting to the test card.
                    . Program card-f0 to generate a Mwr to a test register in
                      BAR 0 of card-f1 with EP=1.
                    . Verify that card-f1 receives a Mwr with EP=1.
| MF_ADR_060_010 a| . Disable poisoned TLP egress blocking in the root ports
                      connecting to the test card.
                    . Program card-f0 to write a system memory location with
                      poisoned data (EP=1).
                    . Read the memory location written by the card-f0 from a
                      RISC-V application processor hart and verify that a
                      hardware error exception occurs.
                    . Program card-f0 to read the previously written memory
                      location and verify that the data is returned in a
                      completion with with EP=1.
| MF_ADR_070_010 a| See MF_ADR_060_010.
|===

==== ID Routed Transactions

[width=100%]
[%header, cols="8,25"]
|===
| ID#            ^| Algorithm
| MF_IDR_010_010 a| . Use PCIe discovery to locate the RISC-V PCIe test card.
                      The test card must be connected directly to the root port.
                    . Program the test card to generate a type 0 and a type 1
                      CfgRd request.
                    . Verify that the card receives a Unsupported Request (UR)
                      response.
| OF_IDR_020_010 a| This test is optional and can be skipped if P2P routing of
                    PCIe VDMs is not supported. This test requires the use of
                    two functions of the RISC-V PCIe test card. One function
                    - card-f0 - is used as an initiator and the second function
                    - card-f1 - is used as a responder.

                    . Program the card-f0 to generate a MCTP VDM with the
                      card-f1 as the destination.
                    . Verify that the VDM is received by card-f1.
| OF_IDR_030_010 a| No tests.
|===

==== Cacheability and Coherence

No tests are defined for these requirements.

==== Message signaled interrupts

A message signaled interrupt (MSI or MSI-X) is the preferred interrupt signaling
mechanism in PCIe.

[%header, cols="8,25"]
|===
| ID#            ^| Algorithm
| ME_MSI_010_010 a| . Locate all RCiEP and PCIe root ports in the system and verify
                      that the Interrupt Pin Register reads 0 indicating that the
                      function does not use legacy interrupt messages.
                    . Verify that all PCIe root ports support MSI and/or MSI-X
                      capability.
| ME_MSI_020_010 a| No test.
| ME_MSI_030_010 a| See ME_MSI_010_010.
|===

==== Precision Time Measurement (PTM)

[width=100%]
[%header, cols="8,25"]
|===
| ID#            ^| Algorithm
| OE_PTM_010_010 a| For each PCIe root ports, report the PCIe PTM capability if
                    present in the test output log.
| OE_PTM_020_010 a| No test.
| OE_PTM_030_010 a| No test.
|===

==== Error and Event Reporting

[width=100%]
[%header, cols="8,25"]
|===
| ID#            ^| Algorithm
| ME_AER_010_010 a| For each PCIe root port, verify that the AER extended
                    capability is supported.
| ME_AER_020_010 a| For each PCIe root port, verify that the DPC extended
                    capability is supported.
| ME_AER_030_010 a| For each PCIe root port, verify that the RP extensions
                    for DPC is supported in the DPC extended capability.
| OE_AER_040_010 a| For each RCiEP, report the presence of AER extended
                    capability in the test output log.
| ME_AER_050_010 a| For each RCiEP, determine if the ACS extended capability is
                    supported and if supported verify that the AER extended
                    capability is also supported.
| ME_AER_060_010 a| If any RCiEP with AER extended capability were detected then
                    verify that there is at least one RCEC in the root complex.
| ME_AER_070_010 a| For each RCEC in the system:

                    . Verify that it implements the RCEC endpoint association
                      extended capability.
                    . Verify that there is an RCEC associated with RCiEP with
                      AER extended capability (See ME_AER_050_010).
|===

==== Vendor Specific Registers

[width=100%]
[%header, cols="8,25"]
|===
| ID#            ^| Algorithm
| MF_VSR_010_010 a| . Use PCIe discovery to locate all RCiEP, root ports, IOMMUs,
                      and host bridges.
                    . For each dicovered function walk the PCIe capability list
                      and verify that the capability ID is one of PCIe specified
                      capabilities.
| MF_VSR_020_010 a| No tests.
|===

<<<

==== SoC-Integrated PCIe Devices

[width=100%]
[%header, cols="8,25"]
|===
| ID#            ^| Algorithm
| MF_SID_010_010 a| No test.

| MF_SID_020_010 a| For all RCiEP and root ports:

                    . Verify that I/O BAR are not implemented.
                    . Verify that no I/O EA capability are implemented.
                    . Interrupt pin register reads 0.
| MF_SID_030_010 a| No test.
| ME_SID_040_010 a| For all RCiEP:

                    . Verify that MSI-X extended capability is supported if
                      SR-IOV extended capability is supported.
| ME_SID_050_010 a| For all RCiEP:

                    . Verify that if PASID extended capability is supported then
                      the maximum PASID width supported is 20.
| ME_SID_060_010 a| No test.
| ME_SID_070_010 a| For all RCiEP:

                    . Verify that if memory BAR are implemented then the BAR
                      supports 64-bit memory space.
| OE_SID_080_010 a| No test.
| ME_SID_090_010 a| For all RCiEP:

                    . Verify if ACS extended capability is supported then AER
                      extended capability is also supported.
| ME_SID_100_010 a| See ME_AER_050_010 and ME_AER_070_010.
|===

<<<

=== Reliability, Availability, and Serviceability (RAS)

No tests are defined for these requirements.

<<<

=== Quality of Service

[width=100%]
[%header, cols="8,25"]
|===
| ID#            ^| Algorithm
| OE_QOS_010_010 a| . Verify that the Ssqosid extension is supported by
                      determining presence of `srmcfg` CSR. Use WARL discovery
                      to determine the range of `RCID` and `MCID` values
                      supported. Report the presence of the extension and the
                      range of `RCID` and `MCID` values into the test output
                      log.
                    . Determine if the system information table enumerates
                      support for the CBQRI extension. If present report
                      support for the CBQRI extension in test output log.
| OE_QOS_020_010 a| See OE_QOS_010_010.
| ME_QOS_030_010 a| If Ssqosid extension is supported, then verify that the
                    `srmcfg` CSR can hold at least 16 RCID and at least 32
                    MCID values. Verify that the supported number of RCID
                    and MCID is identical across all application processor
                    harts.
| OE_QOS_040_010 a| If CBQRI extension is supported, as determined by system
                    information table, then report `capabilities.QOSID` bit
                    of each IOMMU in the test output log.
| OE_QOS_050_010 a| If CBQRI is not supported then this test is skipped.

                    . Determine caches in the Soc using the system information
                      table.
                    . Determine if there is a capacity controller implemented by
                      that cache by looking up the cache ID in system
                      information table and report in test output log whether
                      capacity allocation and capacity monitoring are supported
                      by that capacity controller by accessing the controllers
                      capabilities register.
                    . Using the system information table, locate all bandwidth
                      controllers and report in test output log whether bandwidth
                      allocation and bandwidth monitoring are supported by that
                      bandwidth controller by accessing the controllers capabilities
                      register.
| OE_QOS_060_010 a| See OE_QOS_050_010.
| OE_QOS_070_010 a| See OE_QOS_050_010.
| OE_QOS_080_010 a| See OE_QOS_050_010.
| ME_QOS_090_010 a| If CBQRI is supported then determine the RCID and MCID count
                    supported by each capacity and bandwidth controller using
                    WARL discovery on their `cc_alloc_ctl` and `bc_alloc_ctl`
                    registers. Verify that each controller supports an identical
                    count for each and that the count matches the number of RCID
                    and MCID that supported by the `srmcfg` CSR.
| ME_QOS_100_010 a| No test.

|===

<<<

=== Manageability

[width=100%]
[%header, cols="8,25"]
|===
| ID#            ^| Algorithm
| OE_MNG_010_010 a| No tests.
| OE_MNG_020_010 a| No tests.
| OE_MNG_030_010 a| No tests.
|===

<<<

=== Performance Monitoring

These tests require the use of a vendor provided API to access the HPMs.

[width=100%]
[%header, cols="8,25"]
|===
| ID#            ^| Algorithm
| OF_SPM_010_010 a| . Determine caches in the SoC using the system information
                      table and obtain their IDs.
                    . Allocate two regions of memory.
                    . For each data cache:
                      .. Use `CBO.FLUSH` to writeback and invalidate the two
                         memory regions from the caches.
                      .. Invoke vendor provided API,  passing the cache ID as a
                         parameter, to determine if the cache supports an HPM.
                      .. If an HPM is supported then invoke the vendor provided
                         API, passing the cache ID and events, to program the
                         HPM.
                      .. Perform a memory copy from one region to another from
                         a hart that can access that cache.
                      .. Use the vendor provided API to read the performance
                         counters and verify that they update.
| OF_SPM_020_010 a| . Obtain the memory ranges from system information table and
                      determine their proximity domains.
                    . For each proximity domain:
                      .. Allocate a region of memory in each proximity domain.
                    . For each proximity domain - P:
                      .. Use `CBO.FLUSH` to writeback and invalidate the
                         memory regions from the caches.
                      .. Invoke vendor provided API, passing the proximity
                         domain as a parameter, to determine if the memory
                         controller supports an HPM.
                      .. If an HPM is supported then invoke the vendor provided
                         API, passing the proximity domain and events, to
                         program the HPM to count local/remote read/write
                         bandwidth appropriately.
                      .. Perform a memory copy from the region allocated in P
                         to the region allocated in each of the other proximity
                         domains from a hart with affinity to P.
                      .. Use the vendor provided API to read the performance
                         counters and verify that they update.
                    . Repeat previous step but now copy to the region allocated
                      in P from each of the other proximity domains and verify
                      that the counters update.
| OF_SPM_030_010 a| . Use PCIe discovery to locate the RISC-V PCIe test card.
                    . Determine the PCIe root port to which the card is
                      connected.
                    . Use vendor provided API, passing the test card and root
                      port requester ID to determine if there is the PCie port
                      supports an HPM.
                    . If an HPM is supported then invoke the vendor provided
                      API, passing the PCie root port RID and program the HPM
                      to count read bandwidth.
                    . Program test card to read from system memory.
                    . Use the vendor provided API to read performance counters
                      and verify they update.
                    . Repeat previous steps but with counter programmed to
                      count write bandwidth and the test card programmed to
                      write to system memory.
| OF_SPM_040_010 a| Use algorithm from OF_SPM_020_010.
| OE_SPM_050_010 a| For all PCIe root ports, report in the test output log if
                    the Flit performance measurement extended capability is
                    supported.
|===

<<<

=== Security Requirements

[width=100%]
[%header, cols="8,25"]
|===
| ID#            ^| Algorithm
| OE_SEC_010_010 a| For all PCIe root ports, report if the IDE extended
                    capability is supported in the test output log.
| OE_SEC_020_010 a| No tests.
| OE_SEC_030_010 a| Report if system memory ranges are reported as crypto
                    capable (EFI_MEMORY_CPU_CRYPTO) in the UEFI memory map.
| OE_SEC_040_010 a| . Report if the EFI TPM2 protocol is supported.
                    . If EFI TPM2 protocol is supported, report the TPM present
                      flag by retrieving the boot service capabilities.
|===

== RISC-V PCIe Test Card

A PCIe test card is required to create stimulus for a subset of the tests. This
section outlines the design of such a test card. The PCIe test card shall be
designed to support a x1 PCIe lane and at least Gen 3 speeds. The test card
shall be implemented as a single device with two functions. Each function
implements the standard PCIe type 0 header and the following PCIe capabilities:

* PCIe Capability
* MSI Capability
* Power Management Capability
* ATS Capability
* DVSEC capability

Each function shall support a 64-bit memory BAR. The functions should support
all legal values of Max_Payload_Size.

The DVSEC capability of the function shall provide the following registers:

* `TEST_REG_1` - a 32-bit wide test register that can be written with a value
   between 0 and 8191. When the register is written with a value of `X`, the
   function will generate a completion for the CfgWr transaction that writes
   the register after a delay of `X` nanoseconds.

* `TEST_REG_2` - a 32-bit wide register that may be configured with a value
  that represents the duration in nanoseconds that the device should wait
  before starting to respond to transactions following a FLR.

The BAR 0 of the functions provide the following registers:

* `TEST_POISON_REG` - a 64-bit wide test register which always returns a EP=1
  completion on read.

* `SCRATCHPAD` - a 4 KiB read/write scratchpad register space that can be
  written using Mrd/Mwr transactions and supports all legal address and byte
  enable rules.

* `INJECTED_TLP` - a set of registers that can be used to setup the TLP header
  and if required the data payload of the TLP.

* `INJECT_TLP` - a control register to request the card to originate the TLP
  programmed in `INJECTED_TLP`.

* `LAST_RX_TLP` - a set of registers that hold the header and payload of the
  last TLP received by the function.
